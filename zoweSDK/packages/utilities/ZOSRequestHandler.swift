//
//  ZOSRequestHandler.swift
//  Zowe SDK
//
//  This program and the accompanying materials are made available under the terms of the
//  Eclipse Public License v2.0 which accompanies this distribution, and is available at
//  https://www.eclipse.org/legal/epl-v20.html
//  SPDX-License-Identifier: EPL-2.0
//
//  Copyright Â© 2020 Contributors to the Zowe Project. All rights reserved.
//

import Foundation

/// z/OS REST API HTTP request class
internal class ZOSRequestHandler: NSObject, URLSessionDelegate {
    
    // MARK: - ZOSRequestHandler private members
    
    /// z/OS REST API connection object (generated by the ZoweSDK object)
    private let connection: ZOSConnection
    
    /// Zowe SDK session arguments (generated by the ZosmfApi object)
    private let sessionArguments: (timeout: Double, timeoutForRequest: Double)
    
    // MARK: - ZOSRequestHandler internal members
    
    /// List of supported HTTP request methods
    internal enum ValidMethods: String {
        case GET
        case POST
        case PUT
        case DELETE
    }
    
    // MARK: - ZOSRequestHandler constructor
    
    /// ZosmfRequestHandler object constructor
    /// - Parameters:
    ///   - connection: z/OS REST API connection object (generated by the ZoweSDK object)
    ///   - sessionArguments: Zowe SDK session arguments (generated by the ZosmfApi object)
    internal init(
        _ connection: ZOSConnection,
        _ sessionArguments: (Double, Double)
    ) {
        self.connection = connection
        self.sessionArguments = sessionArguments
    }
    
    // MARK: - ZOSRequestHandler internal methods
    
    /// Prepares and executes an HTTP request based on the given arguments and returns either a validated JSON response or an error message
    /// - Parameters:
    ///   - httpMethod: The HTTP request method that should be used
    ///   - requestArguments: The dictionary containing the HTTP request arguments
    ///   - onCompletion: The closure with the validated JSON response
    ///   - response: The JSON response from z/OS system with the result of the operation or an error description.
    internal func performRequest(
        _ httpMethod: ValidMethods,
        _ requestArguments: (url: URL, headers: Dictionary<String, String>, body: Any?),
        onCompletion: @escaping (_ response: String) -> Void
    ) {
        let configuration = URLSessionConfiguration.default
        configuration.timeoutIntervalForRequest = sessionArguments.timeoutForRequest
        let queue = OperationQueue.main
        let session = URLSession(configuration: configuration, delegate: self, delegateQueue: queue)
        var request = URLRequest(url: requestArguments.url)
        request.httpMethod = httpMethod.rawValue
        request.timeoutInterval = sessionArguments.timeout
        requestArguments.headers.forEach {
            request.setValue($0.value, forHTTPHeaderField: $0.key)
        }
        if requestArguments.headers["Content-Type"]?.contains("text/plain") == true,
            let body = requestArguments.body as? String {
            request.httpBody = Data(body.utf8)
        }
        if requestArguments.headers["Content-Type"]?.contains("application/json") == true,
            let body = requestArguments.body as? [String: Any] {
            do {
                request.httpBody = try JSONSerialization.data(withJSONObject: body)
            } catch {
                onCompletion(ZOSError.invalidHttpBody(reason: error.localizedDescription).errorDescription!)
                return
            }
        }
        
        let task = session.dataTask(with: request, completionHandler: { [weak self] data, response, error in
            let validatedResponse = self?.validateResponse(data, response, error)
            onCompletion(validatedResponse ?? "No response")
        })
        
        task.resume()
    }
    
    // MARK: - ZOSRequestHandler private methods
    
    /// Checks response data and returns either a validated JSON response or an error message
    /// - Parameters:
    ///   - data: Response data
    ///   - response: Response object
    ///   - error: Error if any
    /// - Returns: JSON-converted string
    private func validateResponse(
        _ data: Data?,
        _ response: URLResponse?,
        _ error: Error?
    ) -> String? {
        if let error = error {
            return error.localizedDescription
        } else {
            if let response = response as? HTTPURLResponse {
                if let data = data, data.count > 0 {
                    return String(data: data, encoding: .utf8)
                } else {
                    return ZOSError.httpStatus(code: response.statusCode).errorDescription
                }
            }
        }
        return nil
    }
    
    // MARK: - URLSessionDelegate methods
    
    /// Requests credentials from the delegate in response to a session-level authentication request from the remote server
    /// - Parameters:
    ///   - session: The session containing the task that requested authentication
    ///   - challenge: An object that contains the request for authentication
    ///   - completionHandler: A handler that the delegate method must call
    /// - See Also: [urlSession(_:didReceive:completionHandler:)](https://developer.apple.com/documentation/foundation/urlsessiondelegate/1409308-urlsession)
    internal func urlSession(
        _ session: URLSession,
        didReceive challenge: URLAuthenticationChallenge,
        completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void
    ) {
        let protectionSpace = challenge.protectionSpace
        if protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
            guard connection.zosmfHost.contains(protectionSpace.host),
                let serverTrust = protectionSpace.serverTrust else {
                completionHandler(.performDefaultHandling, nil)
                return
            }
            
            let serverCredentials = URLCredential(trust: serverTrust)
            completionHandler(.useCredential, serverCredentials)
        }
        
        if protectionSpace.authenticationMethod == NSURLAuthenticationMethodClientCertificate {
            let clientCredentials = URLCredential(user: connection.zosmfUser,
                                                  password: connection.zosmfPassword,
                                                  persistence: .forSession)
            completionHandler(.useCredential, clientCredentials)
        }
    }
}
